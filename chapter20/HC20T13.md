import Control.Monad.State
import qualified Data.Map as Map

-- Le type de notre état : un dictionnaire qui mémorise les résultats déjà calculés
type Memo = Map.Map Int Integer

-- Fonction récursive avec mémoïsation
fibonacciMemo :: Int -> State Memo Integer
fibonacciMemo n
    | n == 0 = return 0
    | n == 1 = return 1
    | otherwise = do
        memo <- get
        case Map.lookup n memo of
            Just val -> return val          -- déjà calculé → on le récupère
            Nothing -> do
                a <- fibonacciMemo (n - 1)  -- calcule fib(n-1)
                b <- fibonacciMemo (n - 2)  -- calcule fib(n-2)
                let val = a + b
                modify (Map.insert n val)   -- stocke le résultat
                return val

-- Fonction utilitaire pour exécuter avec état initial vide
runFibonacciMemo :: Int -> Integer
runFibonacciMemo n = evalState (fibonacciMemo n) Map.empty

-- Exemple
main :: IO ()
main = do
    putStrLn "Fibonacci(10) avec mémoïsation :"
    print $ runFibonacciMemo 10

